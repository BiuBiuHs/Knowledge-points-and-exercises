```javascript
/**
 * 定义最小优先级队列类 (修正原笔误：minProtityQueue → minPriorityQueue)
 * 作用：始终保证队列中的元素按节点value升序排列，出队时永远取到权值最小的节点
 * 是构建哈夫曼树的核心容器，哈夫曼树要求每次合并权值最小的两个节点
 */
class minPriorityQueue {
  // 构造函数，初始化队列的存储数组
  constructor() {
    this.element = []; // 存放所有树节点的数组，队列的底层容器
  }

  /**
   * 队列的入队方法：添加节点并重新排序
   * @param {TreeNode} item 入队的树节点对象
   * 核心逻辑：节点入队后，按节点的value值从小到大升序排序
   * 保证队列的头部(this.element[0])永远是权值最小的节点
   */
  enqueue(item) {
    this.element.push(item); // 将节点加入队列尾部
   // 2. 修改minPriorityQueue的enqueue里的sort排序规则
        this.element.sort((a, b) => {
        if (a.value !== b.value) {
            return a.value - b.value; // 优先按权值升序
        } else {
            return a.height - b.height; // ✅权值相等时，按子树高度升序
        }
        });
  }

  /**
   * 队列的出队方法：删除并返回队列头部的元素
   * @returns {TreeNode} 队列中权值最小的树节点
   * 核心逻辑：shift()删除数组第一个元素，正好取到排序后的最小值节点
   */
  dequeue() {
    return this.element.shift();
  }
}

/**
 * 定义哈夫曼树的节点类
 * 每个节点都是一个独立的对象，存储节点的核心信息
 */
// 1. 修改TreeNode类，增加height属性
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.height = 1; // ✅新增：叶子节点的高度默认是1
  }
}





/**
 * 核心构建哈夫曼树的方法
 * @param {Array} nums 原始的叶子节点权值数组（如：[5,15,40,30,10]）
 * @returns {TreeNode} 构建完成后的哈夫曼树的根节点
 */
function buildTree(nums) {
  // 1. 实例化一个最小优先级队列
  let pq = new minPriorityQueue();
  // 2. 遍历原始数组，把每个数值转为树节点并加入优先级队列
  // 入队时队列会自动排序，保证队列内节点按权值升序排列
  nums.map((item) => pq.enqueue(new TreeNode(item)));

  // 3. 核心循环：合并节点，直到队列中只剩一个根节点为止
  // 哈夫曼树的合并规则：队列长度>1时，就需要继续合并
  while (pq.element.length > 1) {
    // 3.1 出队：取出队列中权值最小的两个节点
    let left = pq.dequeue();  // 左节点：权值更小/相等的节点
    let right = pq.dequeue(); // 右节点：权值更大/相等的节点

   // 3. 在buildTree里，生成parentNode时，补充高度计算
    let parentNode = new TreeNode(left.value + right.value);
    parentNode.left = left;
    parentNode.right = right;
    parentNode.height = Math.max(left.height, right.height) + 1; // ✅新增：父节点高度=左右子树最大高+1

    // 3.4 把新生成的父节点重新入队，等待后续合并
    pq.enqueue(parentNode);
  }
  // 4. 循环结束后，队列中仅剩最后一个节点，就是哈夫曼树的根节点
  let root = pq.dequeue();
  return root;
}

/**
 * 对哈夫曼树执行【中序遍历】，收集所有节点的权值
 * 中序遍历规则：左子树 → 根节点 → 右子树 （二叉树标准中序遍历）
 * @param {TreeNode} root 哈夫曼树的根节点
 * @returns {Array} 中序遍历的结果数组，按遍历顺序存储所有节点权值
 */
function getTreeValues(root) {
  let res = []; // 存储遍历结果的数组

  // 定义递归遍历的内部函数
  function loopTree(node) {
    if (!node) return; // 递归终止条件：节点为空时，直接返回
    const { left, right, value } = node; // 解构当前节点的属性
    loopTree(left);  // 递归遍历左子树
    res.push(value); // 访问当前根节点，把权值存入结果数组
    loopTree(right); // 递归遍历右子树
  }
  loopTree(root); // 从根节点开始递归遍历
  return res;
}

/**
 * 对外暴露的主入口方法：构建哈夫曼树 + 中序遍历获取结果
 * @param {Array} nums 原始的叶子节点权值数组
 * @returns {Array} 哈夫曼树中序遍历的最终结果数组
 */
function buildHarfmanTree(nums) {
  const rootNode = buildTree(nums); // 构建哈夫曼树，获取根节点
  return getTreeValues(rootNode);   // 中序遍历，返回结果数组
}

console.log(buildHarfmanTree([5, 15, 40, 30, 10]));

```
