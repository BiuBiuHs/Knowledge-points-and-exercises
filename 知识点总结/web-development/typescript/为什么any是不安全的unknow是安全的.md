在 TypeScript 中，`any` 和 `unknown` 都用于表示「类型不确定」的值，但核心差异在于 **TypeScript 对两者的类型检查策略**：`any` 完全关闭类型检查（放任所有操作），而 `unknown` 强制开发者先验证类型再操作——这是「不安全」与「安全」的本质区别。

### 一、先明确核心结论

| 特性                | `any`                              | `unknown`                          |
|---------------------|------------------------------------|------------------------------------|
| 类型检查            | 完全绕过 TS 类型检查，任意操作都不报错 | 严格类型检查，**必须先验证类型**才能操作 |
| 赋值规则            | 可赋值给任意类型（如 `any → string`） | 仅可赋值给 `unknown`/`any`，不可直接赋值给其他类型 |
| 操作自由度          | 可调用任意方法、访问任意属性        | 不可直接调用方法/访问属性，需类型守卫 |
| 安全风险            | 编译期无校验，错误留到运行时        | 编译期强制校验，提前规避运行时错误  |

### 二、`any` 的「不安全」：彻底放弃类型检查

`any` 的设计初衷是兼容老 JavaScript 代码，但它的本质是「告诉 TS 编译器：别管这个值的类型，我自己负责」——这直接废掉了 TypeScript 最核心的「静态类型校验」能力，带来三重风险：

#### 1. 任意操作都不报错（编译期遗漏错误）

`any` 类型的值可以调用**任何方法、访问任何属性**，哪怕逻辑上完全错误，TS 编译器也不会提示，错误只会在运行时爆发：

```typescript
let foo: any = 123; // 实际是数字类型

// 编译不报错，但运行时崩溃（数字没有 split 方法）
foo.split(','); 

// 编译不报错，强行给数字赋值字符串属性（JS 允许，但逻辑无意义）
foo.name = "张三"; 

// 编译不报错，将数字类型的 any 赋值给字符串类型变量（类型不匹配）
let bar: string = foo; 
```

#### 2. 丢失类型信息，代码提示失效

TS 的核心价值之一是「类型推导 + 代码提示」，但 `any` 会让 TS 完全失去对值的类型认知，开发者无法通过类型推断理解数据结构，团队协作时极易出错：

```typescript
interface User { name: string; age: number }
let user: any = { name: "张三", age: 18 };

// TS 无法提示 user 的属性（不知道 user 是 User 类型）
user.xxx; // 编译不报错，哪怕 xxx 不存在
```

#### 3. 破坏类型系统的「契约」

TypeScript 的类型系统是「静态契约」，而 `any` 会打破这个契约：比如函数返回 `any`，调用方无法知道返回值的结构，也无法被 TS 校验，相当于回到了纯 JavaScript 的「无类型」状态。

### 三、`unknown` 的「安全」：强制类型验证后再操作

`unknown` 是 TS 3.0 引入的「安全版 any」，它表示「类型未知，但必须先验证类型才能使用」——既保留了「类型不确定」的灵活性，又守住了类型检查的底线。

#### 1. 直接操作会报错（强制先校验）

`unknown` 类型的值**不能直接调用方法、访问属性，也不能直接赋值给其他类型**，必须通过「类型守卫」（`typeof`/`instanceof`/类型断言/自定义类型保护）验证类型后，才能进行对应操作：

```typescript
let foo: unknown = 123;

// 编译报错：unknown 类型不能调用 split 方法
foo.split(','); 

// 编译报错：unknown 不能直接赋值给 string 类型
let bar: string = foo; 

// ✅ 安全操作：先通过 typeof 验证类型
if (typeof foo === 'string') {
  foo.split(','); // 编译通过（TS 知道此时 foo 是 string 类型）
  let bar: string = foo; // 编译通过
}

// ✅ 安全操作：通过 instanceof 验证引用类型
foo = new Date();
if (foo instanceof Date) {
  foo.getFullYear(); // 编译通过（TS 知道 foo 是 Date 类型）
}

// ✅ 安全操作：类型断言（需开发者确保类型正确）
(foo as string).split(','); 
```

#### 2. 赋值规则严格（避免类型污染）

`unknown` 是所有类型的「父类型」（和 `any` 一样），但赋值时仅允许：

- 赋值给 `unknown` 或 `any` 类型；
- 验证类型后，赋值给对应类型。

这避免了 `any` 那种「把未知类型随意赋值给其他类型」的风险：

```typescript
let u: unknown = "hello";
let a: any = u; // 允许（any 兼容所有）
let u2: unknown = u; // 允许（同类型）

let s: string = u; // 直接赋值：编译报错
if (typeof u === 'string') {
  let s: string = u; // 验证后：允许
}
```

#### 3. 保留类型系统的完整性

`unknown` 不会让 TS 丢失类型信息：验证类型后，TS 会恢复对值的类型推导，代码提示、类型校验全部生效，既兼容「类型不确定」的场景（如 API 返回值、用户输入），又保证了编译期的类型安全。

### 四、`any` vs `unknown` 核心对比示例

假设我们要处理一个「可能是字符串/数字/对象」的未知值，对比两者的处理方式：

#### 1. 使用 `any`（不安全）

```typescript
function processValue(value: any) {
  // 编译不报错，但运行时若 value 不是字符串会崩溃
  return value.toUpperCase(); 
}

// 传入数字，编译不报错，运行时报错
processValue(123); 
```

#### 2. 使用 `unknown`（安全）

```typescript
function processValue(value: unknown) {
  // 必须先验证类型
  if (typeof value === 'string') {
    return value.toUpperCase(); // 仅字符串时执行
  }
  // 非字符串时返回默认值，避免运行时错误
  return "无效值"; 
}

// 传入数字，编译通过，返回 "无效值"（运行时安全）
processValue(123); 
```

### 五、使用场景建议

| 场景                                  | 推荐使用       | 原因                                  |
|---------------------------------------|----------------|---------------------------------------|
| 兼容老 JS 代码、第三方库无类型定义    | `any`（尽量少用） | 临时兼容，需注释说明类型              |
| API 返回值、用户输入、类型不确定的场景 | `unknown`      | 强制安全处理，避免运行时错误          |
| 函数参数/返回值需要灵活类型但需安全   | `unknown`      | 保留灵活性，同时守住类型检查底线      |
| 完全不需要类型检查的临时变量          | `any`          | 仅临时使用，不推荐在生产代码中大量用  |

### 六、总结：为什么 `unknown` 安全，`any` 不安全？

- `any` 的本质是「放弃类型检查」：允许任意操作、任意赋值，把类型错误留到运行时，违背了 TypeScript 的核心目标；
- `unknown` 的本质是「延迟类型检查」：承认类型未知，但强制开发者在使用前验证类型，将类型错误提前到编译期解决——这正是 TypeScript 作为「静态类型语言」的价值所在。

一句话概括：`any` 是「放任不管」，`unknown` 是「先验后用」，后者才符合 TypeScript 「安全且灵活」的设计理念。
