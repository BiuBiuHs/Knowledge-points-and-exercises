### 一、window.open 打开新窗口的**数据共享方式**

数据共享的核心差异是「同源」和「跨源」，以下是不同场景下的可行方案：

#### 1. 同源场景（协议、域名、端口完全一致）

同源窗口可直接访问彼此的上下文，或使用浏览器存储/通信 API：

| 方案 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| `opener` 直接关联 | 新窗口的 `opener` 指向父窗口，父窗口持有新窗口引用，可直接读写全局变量/存储 | 简单、实时、无容量限制 | 依赖窗口引用，新窗口关闭/刷新后失效；需处理加载时机（避免未加载完成就操作） |
| `LocalStorage` | 同源下所有窗口共享，持久化存储（除非手动清除） | 共享性好、容量大（≈5MB） | 持久化（关闭浏览器仍存在）；写入是同步操作，大量数据会阻塞主线程 |
| `Broadcast Channel API` | 同源窗口通过创建同名频道实现消息广播/接收 | 异步、解耦（无需窗口引用） | 仅支持同源；部分旧浏览器（如 IE）不兼容 |
| `SharedWorker` | 多个同源窗口共享一个 Worker 线程，通过 Worker 中转数据 | 适合复杂逻辑/大量数据交互 | 实现稍复杂；需处理 Worker 连接/断开 |
| `IndexedDB` | 同源下的本地数据库，异步存储 | 容量极大（GB 级）；支持复杂查询 | 学习成本高；异步操作需处理回调/Promise |

#### 2. 跨源场景（协议/域名/端口任意不一致）

跨源仅能通过 `postMessage` 实现安全的数据通信：

- 原理：父窗口向新窗口发送消息，新窗口监听 `message` 事件接收；反之亦然。
- 核心：必须验证消息来源（`e.origin`），避免恶意注入。

#### 关键提醒：SessionStorage 本身不支持跨窗口共享

`SessionStorage` 的作用域是「单个浏览上下文」（单个标签页/窗口），即使同源，不同标签页的 `SessionStorage` 也**默认独立**；但可通过 `opener` 访问父窗口的 `SessionStorage`（间接共享）。

---

### 二、SessionStorage 的限制及超出限制的后果

#### 1. 核心限制

| 限制项 | 具体规则 |
|--------|----------|
| 容量限制 | 主流浏览器（Chrome/Edge/Firefox/Safari）均为 **每个域名 ≈5MB**（按 UTF-16 字符计算：1 字符 = 2 字节，5MB ≈ 250 万字符）；部分浏览器（如 Safari 移动端）可能略低（≈2.5MB）。 |
| 数据类型 | 仅支持字符串键值对，非字符串（如对象/数字）需通过 `JSON.stringify` 序列化，读取时 `JSON.parse` 解析。 |
| 作用域 | ① 同源限制（非同源无法访问）；② 浏览上下文限制（仅当前标签页/窗口可用，关闭后数据清除）；③ 若新窗口通过 `window.open` 打开且未设置 `noopener/noreferrer`，可通过 `opener` 访问父窗口的 SessionStorage。 |
| 操作特性 | 同步操作（写入/读取会阻塞主线程）；不支持跨域；无法被爬虫读取。 |

#### 2. 超出容量限制的后果

当调用 `sessionStorage.setItem()` 写入数据超出容量时：

- **主流浏览器（Chrome/Edge/Firefox）**：抛出 `DOMException` 错误，类型为 `QuotaExceededError`（配额超出），**数据不会被存储**，原有数据也不会被覆盖。
- **旧浏览器（如 IE）**：静默失败（不报错，但数据写入无效）。
- **附加影响**：无其他副作用（如不会导致浏览器崩溃、不会清空已有数据）。

---

### 三、实操示例

#### 示例 1：同源下通过 opener 共享 SessionStorage（间接）

```javascript
// 父窗口（parent.html）
const newWin = window.open('child.html', '_blank');
// 等待新窗口加载完成
newWin.onload = function() {
  // 父窗口写入自己的 SessionStorage
  sessionStorage.setItem('parentData', JSON.stringify({ name: '父窗口', value: 123 }));
  // 新窗口通过 opener 访问父窗口的 SessionStorage
  console.log('新窗口读取父窗口数据：', newWin.opener.sessionStorage.getItem('parentData'));
};

// 子窗口（child.html）
// 访问父窗口的 SessionStorage
const parentData = JSON.parse(opener.sessionStorage.getItem('parentData'));
console.log(parentData); // { name: '父窗口', value: 123 }

// 子窗口向父窗口回传数据
opener.sessionStorage.setItem('childData', JSON.stringify({ name: '子窗口', value: 456 }));
```

#### 示例 2：跨源下通过 postMessage 共享数据

```javascript
// 父窗口（http://a.com）
const newWin = window.open('http://b.com/child.html', '_blank');
// 等待新窗口加载完成后发送消息
newWin.onload = function() {
  newWin.postMessage(
    { data: '跨源数据' },
    'http://b.com' // 仅允许发送到该域名，* 表示所有域（不安全）
  );
};
// 监听子窗口的回复
window.addEventListener('message', (e) => {
  // 严格验证来源，防止恶意消息
  if (e.origin === 'http://b.com') {
    console.log('父窗口收到跨源回复：', e.data);
  }
});

// 子窗口（http://b.com/child.html）
window.addEventListener('message', (e) => {
  // 验证消息来源
  if (e.origin === 'http://a.com') {
    console.log('子窗口收到跨源消息：', e.data);
    // 回复父窗口
    e.source.postMessage('已收到数据', e.origin);
  }
});
```

#### 示例 3：测试 SessionStorage 容量限制

```javascript
function testSessionStorageLimit() {
  let testData = '';
  const chunk = 'a'.repeat(1024); // 每次追加 1KB 字符串
  try {
    while (true) {
      sessionStorage.setItem('test', testData);
      testData += chunk;
    }
  } catch (e) {
    // 捕获配额超出错误
    if (e.name === 'QuotaExceededError') {
      const usedKB = (testData.length * 2) / 1024; // UTF-16 转 KB
      console.log(`SessionStorage 容量限制：≈${Math.round(usedKB)} KB`);
      console.error('超出容量错误：', e);
    }
  }
}
testSessionStorageLimit(); // 输出约 5000 KB（5MB）
```

---

### 四、总结

1. **数据共享选型**：
   - 同源简单场景：用 `opener` 直接关联；
   - 同源解耦场景：用 `Broadcast Channel`；
   - 跨源场景：必须用 `postMessage`（务必验证 `origin`）；
   - 大量数据：用 `IndexedDB`/`SharedWorker`。
2. **SessionStorage 注意点**：
   - 容量 ≈5MB/域名，超出抛 `QuotaExceededError`；
   - 本身不跨窗口共享，需通过 `opener` 间接访问父窗口的 SessionStorage；
   - 关闭标签页后数据自动清除，适合临时存储。
