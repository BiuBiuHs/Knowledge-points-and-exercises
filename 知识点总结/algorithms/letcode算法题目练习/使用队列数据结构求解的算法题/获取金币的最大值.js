// 给定一个数组 A[]，每个位置 i 放置了金币 A[i]，小明从 A[0] 出发。当小明走到 A[i] 的时候，下一步他可以选择 A[i+1, i+k]（当然，不能超出数组边界）。
// 每个位置一旦被选择，将会把那个位置的金币收走（如果为负数，就要交出金币）。请问，最多能收集多少金币？

// 输入：[1,-1,-100,-1000,100,3], k = 2

// 输出：4

// 解释：从 A[0] = 1 出发，收获金币 1。下一步走往 A[2] = -100, 收获金币 -100。
// 再下一步走到 A[4] = 100，收获金币 100，最后走到 A[5] = 3，收获金币 3。
// 最多收获 1 - 100 + 100 + 3 = 4。没有比这个更好的走法了。


function maxCoin (coins,k) {
    const queue = []
    const get =[]
    const n  = coins.length 

    for(var i = 0; i < n ; i++){
        if(i - k >0) {
            //已经入队过 k 个元素 此时为第k + 1个元素 因此要缩小队列的范围 判断队首是否要出队
            // 在取最大值之前，需要保证单调队列中都是有效值。
            // 也就是都在区间里面的值
            // 当要求get[i]的时候，
            // 单调队列中应该是只能保存[i-k, i-1]这个范围
            if(queue.length && queue[0] === get[i - k - 1]){
                queue.shift()
            }
        }
        //获取队列的最大值 即队首元素
        //如果队列为空此时返回0即可
        const cur = queue.length ? queue[0] : 0
        //生成get队列的值 
        //生成规则为 使用队列的最大值 + 当前数组的值 生成最优解 get[i]
        get[i] = cur + conis[i]
        while(queue.length && queue[length -1] < get[i]){
            queue.pop()
        }
        queue.push(get[i])
    }
    return  
}