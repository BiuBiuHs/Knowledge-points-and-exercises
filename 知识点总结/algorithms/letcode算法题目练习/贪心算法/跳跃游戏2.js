
// https://leetcode.cn/problems/jump-game-ii/description/
// 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

// 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

// 0 <= j <= nums[i] 
// i + j < n
// 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

 

// 示例 1:

// 输入: nums = [2,3,1,1,4]
// 输出: 2
// 解释: 跳到最后一个位置的最小跳跃数是 2。
//      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
// 示例 2:

// 输入: nums = [2,3,0,1,4]
// 输出: 2
 

// 提示:

// 1 <= nums.length <= 104
// 0 <= nums[i] <= 1000
// 题目保证可以到达 nums[n-1]


// 题解

// 正向查找可到达的最大位置
// 方法一虽然直观，但是时间复杂度比较高，有没有办法降低时间复杂度呢？

// 如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。

// 例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。

// 从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。
// 在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。

// 在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。
// 如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。


/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    let len  = nums.length;
    let end = 0 ; //初始的结束位置
    let maxPosition = 0; //能够跳跃的最远位置
    let steps = 0 ; //跳跃的次数
    for(var i = 0 ;i < len - 1 ; i++){  //遍历整个数组
        //相当于每次跳跃都 寻找在当前位置能够达到的最大位置 
        maxPosition = Math.max(maxPosition, i + nums[i]) //将当前的位置的值 + 当前的位置索引 index  作为能够跳跃的最远位置 

        if(i == end){ //如果遍历到 上一步能够达到的最大位置 ，则说明需要进行下一次跳跃了。
            end = maxPosition;  //更新 束位置为 当前可以跳跃的最大位置
            steps++; //跳跃次数++
        }
        
    }
    return steps 
  };