// 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

// 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

// 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
// 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

// 示例 1：

// 输入：text1 = "abcde", text2 = "ace"
// 输出：3
// 解释：最长公共子序列是 "ace" ，它的长度为 3 。

### 问题定义

给定两个序列 A 和 B，长度分别为 n 和 m，我们需要找到一个最长的序列 C，使得 C 既是 A 的子序列，也是 B 的子序列。

### 动态规划解法

#### 状态定义

定义一个二维数组 `dp`，其中 `dp[i][j]` 表示序列 A 的前 i 个元素和序列 B 的前 j 个元素的最长公共子序列的长度。

#### 状态转移方程

- 如果 A[i-1] = B[j-1]，则 `dp[i][j] = dp[i-1][j-1] + 1`。
- 如果 A[i-1] \neq B[j-1]，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。

#### 初始化

- `dp[0][j] = 0`，因为 A 的前 0 个元素（即空序列）和 B 的前 j 个元素的最长公共子序列长度为 0。
- `dp[i][0] = 0`，因为 A 的前 i 个元素和 B 的前 0 个元素（即空序列）的最长公共子序列长度为 0。

#### 代码实现

```javascript
function longestCommonSubsequence(A, B) {
    const n = A.length;
    const m = B.length;
    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));

    // 填充 DP 表
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (A[i - 1] === B[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    //求长度则 直接返回 return dp[n][m] 即可
    // return dp[n][m]

    // 构造最长公共子序列
    let lcs = [];
    let i = n, j = m;
    while (i > 0 && j > 0) {
        if (A[i - 1] === B[j - 1]) {
            lcs.unshift(A[i - 1]);
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return lcs;
}

// 示例
const A = [1, 2, 3, 4, 1];
const B = [3, 4, 1, 2, 1, 3];
const result = longestCommonSubsequence(A, B);
console.log(result); // 输出: [3, 4, 1]
```

### 解释

1. **初始化 DP 表**：创建一个大小为 \((n+1) \times (m+1)\) 的二维数组 `dp`，并初始化为 0。
2. **填充 DP 表**：遍历数组 `A` 和 `B`，根据状态转移方程更新 `dp` 表。
3. **构造最长公共子序列**：从 `dp[n][m]` 开始，回溯构建最长公共子序列。如果 `A[i-1]` 等于 `B[j-1]`，则将该元素加入结果序列，并向前移动两个指针；
否则，移动指针指向较大的 DP 值。
