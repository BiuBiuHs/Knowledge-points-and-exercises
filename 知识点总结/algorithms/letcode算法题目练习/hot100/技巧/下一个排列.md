
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 * 算法功能：求数组的「下一个排列」（字典序中比当前大的最小排列）
 * 核心思路：1. 找升序断点 2. 交换最小更大值 3. 反转变后缀（得到最小后缀）
 * 特殊情况：若数组已是最大排列（完全降序），则反转整个数组得到最小排列
 */
var nextPermutation = function(nums) {
    // 获取数组长度
    let n = nums.length;

    // 步骤1：从后往前找第一个「升序对」的左端点 i（即 nums[i] < nums[i+1]）
    // 目的：i 是当前排列中，能通过交换增大的最右侧位置（保证下一个排列是最小的更大值）
    // 循环条件：nums[i] >= nums[i+1] 说明是降序，继续向左找
    let i = n - 2; // 从倒数第二个元素开始（需比较 i 和 i+1）
    while (i >= 0 && nums[i] >= nums[i+1]) { // 加 i>=0 防止数组越界
        i--;
    }

    // 步骤2：若找到有效 i（说明不是最大排列），寻找右侧比 nums[i] 大的最小数
    if (i >= 0) {
        // 从数组末尾往前找第一个比 nums[i] 大的元素 j
        // 目的：j 对应的值是 nums[i] 右侧最小的更大值，交换后保证前缀最小增大
        let j = n - 1;
        //************ 下方解释了为什么从后往前的第一个大于 位置于x的数字就是 最小大于x的数字 ************/
        //因为此时i与 i+1 是第一个升序数字对 比如 [1,3,5,4,2] 中的 3、5
        //此时3的右侧 一定是降序的 所以找到的第一个大于3的数字一定是 最小的大于3的数字
        while (nums[j] <= nums[i]) { // 降序遍历，找到第一个大于 nums[i] 的值
            j--;
        }
        // 交换 i 和 j 位置的元素：完成前缀的最小增大
        [nums[i], nums[j]] = [nums[j], nums[i]];
    }

    // 步骤3：反转 i+1 到数组末尾的元素
    // 原因：交换后，i+1 到末尾仍是降序（原先是降序，交换后不改变降序特性）
    // 反转后变为升序，是当前前缀下的最小后缀，整体构成下一个最小排列
    let left = i + 1; // 反转的左边界（i+1 开始）
    let right = n - 1; // 反转的右边界（数组末尾）
    // 双指针反转数组片段（原地修改）
    while (left < right) { // 这里用 left < right 即可，无需 <=（相等时无需交换）
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++; // 左指针右移
        right--; // 右指针左移
    }

    // 最终：nums 已被修改为下一个排列（原地修改，无返回值）
};
```

### 补充注释：关键逻辑解读

1. **为什么从后往前找升序对？**
   字典序的下一个排列要求「尽可能少的改变右侧元素」，从后往前找第一个可增大的位置 `i`，能保证修改后的排列是「最小的更大值」（比如 `[1,3,2]`，`i=0`（1<3），而非 `i=1`（3>2））。

2. **为什么交换后要反转变后缀？**
   交换 `i` 和 `j` 后，`i+1` 到末尾仍是**降序**（原数组从 `i` 往后是降序，交换 `j`（右侧最大的比 `nums[i]` 大的值）后，后缀仍保持降序）。降序是当前后缀的最大值，反转后变为升序（最小值），才能保证整体是下一个最小排列。

3. **i<0 的情况处理？**
   当 `i<0` 时，说明数组是完全降序（如 `[3,2,1]`），已是最大排列。此时步骤3会反转整个数组（`left=0`，`right=n-1`），得到最小排列 `[1,2,3]`，符合题目要求。
