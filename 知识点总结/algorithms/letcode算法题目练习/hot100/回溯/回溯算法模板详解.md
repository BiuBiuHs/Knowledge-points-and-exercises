# 回溯算法模板详解

## 回溯算法核心模板

```javascript
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    
    for (选择 : 本层集合中的元素) {
        处理节点;
        backtracking(路径, 选择列表); // 递归
        撤销处理; // 回溯
    }
}
```

## 模板各部分详解

### 1. 函数参数

```javascript
void backtracking(参数)
```

**作用**：定义回溯函数的参数

**常见参数**：

- `路径`：当前已经做出的选择（如 `temp`、`path`）
- `选择列表`：当前可以做的选择（如 `start`、`index`）
- `其他辅助参数`：如 `target`、`sum` 等

**示例**：

```javascript
function backtrack(path, start, target) {
    // path: 当前路径 [1, 2, 3]
    // start: 从哪个位置开始选择
    // target: 目标值
}
```

### 2. 终止条件

```javascript
if (终止条件) {
    存放结果;
    return;
}
```

**作用**：判断是否已经找到答案，需要停止递归

**常见终止条件**：

- 路径长度达到要求：`path.length === n`
- 路径和达到目标：`sum === target`
- 已经遍历完所有元素：`index >= nums.length`
- 满足特定条件：如括号匹配、N皇后等

**示例**：

```javascript
// 子集问题：路径长度达到要求
if (path.length === nums.length) {
    res.push([...path]);
    return;
}

// 组合问题：路径和达到目标
if (sum === target) {
    res.push([...path]);
    return;
}

// 全排列问题：已经遍历完所有元素
if (path.length === nums.length) {
    res.push([...path]);
    return;
}
```

### 3. 选择循环

```javascript
for (选择 : 本层集合中的元素) {
    // ...
}
```

**作用**：遍历当前层所有可能的选择

**关键点**：

- **本层集合**：当前可以选择的元素集合
- **避免重复**：通常使用 `start` 或 `index` 参数
- **剪枝优化**：可以在循环中添加条件提前跳过

**示例**：

```javascript
// 从 start 位置开始，避免重复选择
for (let i = start; i < nums.length; i++) {
    // ...
}

// 遍历所有可能的选择
for (let item of choices) {
    // ...
}
```

### 4. 处理节点（选择）

```javascript
处理节点;
```

**作用**：做出选择，将当前元素添加到路径中

**两种写法**：

**写法1：修改原变量（需要回溯）**

```javascript
path.push(nums[i]);        // 数组
sum += nums[i];            // 数值
curStr += "a";            // 字符串
```

**写法2：创建新值（不需要回溯，推荐）**

```javascript
backtrack([...path, nums[i]], i + 1);  // 数组
backtrack(path, i + 1, sum + nums[i]); // 数值
backtrack(curStr + "a", i + 1);        // 字符串
```

### 5. 递归调用

```javascript
backtracking(路径, 选择列表); // 递归
```

**作用**：继续探索下一层

**关键点**：

- 更新路径：添加了当前选择
- 更新选择列表：通常 `start` 或 `index` 加1
- 传递其他参数：如 `sum`、`target` 等

**示例**：

```javascript
// 组合问题：从 i+1 开始，避免重复
backtrack(path, i + 1);

// 全排列问题：需要标记已使用的元素
backtrack(path, used);
```

### 6. 撤销处理（回溯）

```javascript
撤销处理; // 回溯
```

**作用**：撤销刚才的选择，恢复到选择前的状态

**关键点**：

- **必须与"处理节点"对应**：做了什么操作，就要撤销什么操作
- **只有修改原变量时才需要**：如果使用新值，不需要回溯

**示例**：

```javascript
// 数组：pop 对应 push
path.push(nums[i]);
backtrack(path, i + 1);
path.pop();  // 回溯

// 数值：减法对应加法
sum += nums[i];
backtrack(path, i + 1, sum);
sum -= nums[i];  // 回溯

// 字符串：substring 对应 +=
curStr += "a";
backtrack(curStr, i + 1);
curStr = curStr.substring(0, curStr.length - 1);  // 回溯
```

## 完整示例

### 示例1：子集问题（78. 子集）

```javascript
/**
 * 给定一个不含重复元素的整数数组 nums，返回该数组所有可能的子集
 * 输入：nums = [1,2,3]
 * 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
 */
function subsets(nums) {
    let res = [];
    let path = [];
    
    function backtrack(start) {
        // 1. 终止条件：每个节点都是结果（子集问题特殊）
        res.push([...path]);  // 保存当前路径
        
        // 2. 选择循环：从 start 开始，避免重复
        for (let i = start; i < nums.length; i++) {
            // 3. 处理节点：选择当前元素
            path.push(nums[i]);
            
            // 4. 递归：继续探索下一层
            backtrack(i + 1);
            
            // 5. 回溯：撤销选择
            path.pop();
        }
    }
    
    backtrack(0);
    return res;
}
```

**执行过程**：

```
backtrack(0)
  path = []
  保存 [] ✅
  循环 i=0: path.push(1) → path = [1]
    backtrack(1)
      保存 [1] ✅
      循环 i=1: path.push(2) → path = [1,2]
        backtrack(2)
          保存 [1,2] ✅
          循环 i=2: path.push(3) → path = [1,2,3]
            backtrack(3)
              保存 [1,2,3] ✅
              返回
          path.pop() → path = [1,2]
        返回
      path.pop() → path = [1]
      循环 i=2: path.push(3) → path = [1,3]
        backtrack(3)
          保存 [1,3] ✅
          返回
      path.pop() → path = [1]
    返回
  path.pop() → path = []
  循环 i=1: path.push(2) → path = [2]
    ... 继续
```

### 示例2：组合问题（77. 组合）

```javascript
/**
 * 给定两个整数 n 和 k，返回 1...n 中所有可能的 k 个数的组合
 * 输入：n = 4, k = 2
 * 输出：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
 */
function combine(n, k) {
    let res = [];
    let path = [];
    
    function backtrack(start) {
        // 1. 终止条件：路径长度达到 k
        if (path.length === k) {
            res.push([...path]);
            return;
        }
        
        // 2. 选择循环：从 start 到 n
        for (let i = start; i <= n; i++) {
            // 3. 处理节点：选择当前数字
            path.push(i);
            
            // 4. 递归：继续选择下一个数字
            backtrack(i + 1);
            
            // 5. 回溯：撤销选择
            path.pop();
        }
    }
    
    backtrack(1);
    return res;
}
```

### 示例3：全排列问题（46. 全排列）

```javascript
/**
 * 给定一个不含重复数字的数组 nums，返回其所有可能的全排列
 * 输入：nums = [1,2,3]
 * 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 */
function permute(nums) {
    let res = [];
    let path = [];
    let used = new Array(nums.length).fill(false);  // 标记已使用的元素
    
    function backtrack() {
        // 1. 终止条件：路径长度等于数组长度
        if (path.length === nums.length) {
            res.push([...path]);
            return;
        }
        
        // 2. 选择循环：遍历所有元素（全排列需要遍历所有）
        for (let i = 0; i < nums.length; i++) {
            // 剪枝：跳过已使用的元素
            if (used[i]) continue;
            
            // 3. 处理节点：选择当前元素
            path.push(nums[i]);
            used[i] = true;
            
            // 4. 递归：继续选择下一个元素
            backtrack();
            
            // 5. 回溯：撤销选择
            path.pop();
            used[i] = false;
        }
    }
    
    backtrack();
    return res;
}
```

### 示例4：组合总和（39. 组合总和）

```javascript
/**
 * 给定一个无重复元素的数组 candidates 和一个目标数 target
 * 找出 candidates 中所有可以使数字和为 target 的组合
 * 输入：candidates = [2,3,6,7], target = 7
 * 输出：[[2,2,3],[7]]
 */
function combinationSum(candidates, target) {
    let res = [];
    let path = [];
    
    function backtrack(start, sum) {
        // 1. 终止条件：和等于目标值
        if (sum === target) {
            res.push([...path]);
            return;
        }
        
        // 剪枝：和超过目标值，提前返回
        if (sum > target) {
            return;
        }
        
        // 2. 选择循环：从 start 开始，可以重复选择
        for (let i = start; i < candidates.length; i++) {
            // 3. 处理节点：选择当前数字
            path.push(candidates[i]);
            sum += candidates[i];
            
            // 4. 递归：可以重复选择，所以从 i 开始（不是 i+1）
            backtrack(i, sum);
            
            // 5. 回溯：撤销选择
            path.pop();
            sum -= candidates[i];
        }
    }
    
    backtrack(0, 0);
    return res;
}
```

## 模板使用技巧

### 1. 何时需要回溯？

**需要回溯**：

- 使用 `push`、`+=` 等修改原变量
- 使用 `used[i] = true` 标记状态

**不需要回溯**：

- 使用 `[...path, item]` 创建新数组
- 使用 `curStr + item` 创建新字符串
- 传递 `sum + nums[i]` 等新值

### 2. 如何避免重复？

**组合问题**（顺序不重要）：

```javascript
for (let i = start; i < nums.length; i++) {
    backtrack(path, i + 1);  // 从 i+1 开始
}
```

**排列问题**（顺序重要）：

```javascript
let used = new Array(nums.length).fill(false);
for (let i = 0; i < nums.length; i++) {
    if (used[i]) continue;  // 跳过已使用的
    used[i] = true;
    backtrack(path, used);
    used[i] = false;
}
```

### 3. 剪枝优化

```javascript
// 剪枝1：提前终止
if (sum > target) return;

// 剪枝2：跳过重复元素（需要先排序）
if (i > start && nums[i] === nums[i-1]) continue;

// 剪枝3：剩余元素不足
if (path.length + (nums.length - i) < k) return;
```

## 常见问题类型

### 1. 子集问题

- 78. 子集
- 90. 子集 II（含重复元素）

### 2. 组合问题

- 77. 组合
- 39. 组合总和
- 40. 组合总和 II（含重复元素）

### 3. 排列问题

- 46. 全排列
- 47. 全排列 II（含重复元素）

### 4. 字符串问题

- 17. 电话号码的字母组合
- 22. 括号生成

### 5. 棋盘问题

- 51. N 皇后
- 37. 解数独

## 总结

1. **模板结构**：终止条件 → 选择循环 → 处理 → 递归 → 回溯
2. **核心思想**：尝试所有可能，通过回溯撤销错误选择
3. **关键技巧**：
   - 使用 `start` 避免重复组合
   - 使用 `used` 标记已使用元素
   - 及时剪枝优化性能
   - 优先使用新值写法，避免回溯错误
