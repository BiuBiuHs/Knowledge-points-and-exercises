# 回溯算法练习题索引

## 📚 学习路径

### 入门级（掌握基础模板）

1. **78. 子集** ⭐
   - 文件：`练习题-子集.js`
   - 难度：中等
   - 重点：理解每个节点都是结果
   - 关键：`res.push([...path])` 在循环之前

2. **77. 组合** ⭐
   - 文件：`练习题-组合.js`
   - 难度：中等
   - 重点：理解终止条件 `path.length === k`
   - 关键：使用 `start` 避免重复

3. **46. 全排列** ⭐⭐
   - 文件：`练习题-全排列.js`
   - 难度：中等
   - 重点：理解 `used` 数组的使用
   - 关键：全排列需要遍历所有元素

### 进阶级（掌握剪枝和优化）

4. **39. 组合总和** ⭐⭐
   - 文件：`练习题-组合总和.js`
   - 难度：中等
   - 重点：理解可以重复选择（从 `i` 开始）
   - 关键：剪枝 `sum > target`

5. **22. 括号生成** ⭐⭐
   - 文件：`练习题-括号生成.js`
   - 难度：中等
   - 重点：理解左右括号的约束条件
   - 关键：`right < left` 的剪枝

6. **17. 电话号码的字母组合** ⭐
   - 文件：`练习题-电话号码字母组合.js`
   - 难度：中等
   - 重点：理解多层的选择循环
   - 关键：使用新字符串避免回溯

7. **131. 分割回文串** ⭐⭐
   - 文件：`练习题-分割回文串.js`
   - 难度：中等
   - 重点：理解字符串分割的回溯
   - 关键：判断回文串 + 回溯分割点
   - 优化：使用动态规划预处理回文串判断

### 高级（处理复杂情况）

8. **90. 子集 II** ⭐⭐⭐
   - 难度：中等
   - 重点：处理重复元素
   - 关键：排序 + `i > start && nums[i] === nums[i-1]`

9. **40. 组合总和 II** ⭐⭐⭐
   - 难度：中等
   - 重点：处理重复元素 + 不能重复选择
   - 关键：排序 + 剪枝重复

10. **47. 全排列 II** ⭐⭐⭐
    - 文件：`练习题-全排列II.js`
    - 难度：中等
    - 重点：处理重复元素的全排列
    - 关键：排序 + `!used[i-1]` 的剪枝去重
    - 难点：理解为什么 `!used[i-1]` 能去重

11. **51. N 皇后** ⭐⭐⭐⭐
    - 文件：`练习题-N皇后.js`
    - 难度：困难
    - 重点：复杂的约束条件（行、列、对角线）
    - 关键：判断对角线冲突 + 回溯撤销
    - 难点：理解为什么只需要检查上方，如何检查对角线
    - 常见错误：传入错误参数、忘记实现转换函数、忘记回溯

## 🎯 练习建议

### 第一步：理解模板

1. 阅读 `回溯算法模板详解.md`
2. 理解每个部分的作用
3. 理解"选择"和"回溯"的关系

### 第二步：基础练习

1. 先做 **子集** 和 **组合** 问题
2. 理解 `start` 参数的作用
3. 理解为什么子集问题不需要终止条件（每个节点都是结果）

### 第三步：进阶练习

1. 做 **全排列** 问题
2. 理解 `used` 数组的使用
3. 理解组合和排列的区别

### 第四步：优化练习

1. 做 **组合总和** 和 **括号生成**
2. 理解剪枝的重要性
3. 理解何时需要回溯，何时不需要

### 第五步：综合练习

1. 处理含重复元素的问题
2. 处理复杂的约束条件
3. 优化时间和空间复杂度

## 📝 解题步骤

### 1. 分析问题类型

- **子集问题**：每个节点都是结果
- **组合问题**：需要达到特定长度
- **排列问题**：需要遍历所有元素
- **约束问题**：需要满足特定条件

### 2. 确定参数

- `path`：当前路径
- `start/index`：从哪个位置开始选择
- `used`：标记已使用的元素（排列问题）
- `sum/target`：目标和（组合总和问题）
- `left/right`：左右括号数量（括号问题）

### 3. 确定终止条件

- 路径长度达到要求
- 和达到目标值
- 满足特定条件

### 4. 确定选择循环

- 从 `start` 开始（组合问题）
- 从 `0` 开始（排列问题）
- 遍历所有可能的选择

### 5. 处理节点和回溯

- 选择：添加到路径
- 递归：继续探索
- 回溯：撤销选择

## 🔍 常见错误

### 错误1：忘记回溯

```javascript
// ❌ 错误
path.push(nums[i]);
backtrack(path, i + 1);
// 缺少 path.pop()

// ✅ 正确
path.push(nums[i]);
backtrack(path, i + 1);
path.pop();
```

### 错误2：使用引用而不是副本

```javascript
// ❌ 错误
res.push(path);  // path 是引用，会被后续修改

// ✅ 正确
res.push([...path]);  // 创建副本
```

### 错误3：重复选择（组合问题）

```javascript
// ❌ 错误
for (let i = 0; i < nums.length; i++) {
    backtrack(path, i);  // 会重复选择
}

// ✅ 正确
for (let i = start; i < nums.length; i++) {
    backtrack(path, i + 1);  // 从 i+1 开始
}
```

### 错误4：忘记剪枝

```javascript
// ❌ 错误
if (sum === target) {
    res.push([...path]);
    return;
}
// 缺少 sum > target 的剪枝

// ✅ 正确
if (sum > target) return;  // 提前终止
if (sum === target) {
    res.push([...path]);
    return;
}
```

## 💡 优化技巧

### 1. 使用新值传递（推荐）

```javascript
// ✅ 不需要回溯
backtrack([...path, nums[i]], i + 1);
backtrack(curStr + letter, index + 1);
```

### 2. 剪枝优化

```javascript
// 提前终止
if (sum > target) return;

// 跳过重复
if (i > start && nums[i] === nums[i-1]) continue;

// 剩余元素不足
if (path.length + (n - i) < k) return;
```

### 3. 排序预处理

```javascript
// 处理重复元素时，先排序
nums.sort((a, b) => a - b);
```

## 📊 复杂度分析

### 时间复杂度

- **子集问题**：O(2^n × n)
- **组合问题**：O(C(n,k) × k)
- **排列问题**：O(n! × n)

### 空间复杂度

- **递归深度**：O(n)
- **路径存储**：O(n)
- **结果存储**：O(结果数量 × 平均长度)

## 🎓 学习资源

1. **模板详解**：`回溯算法模板详解.md`
2. **练习题**：各个 `练习题-*.js` 文件
3. **LeetCode 官方题解**
4. **可视化工具**：<https://visualgo.net/zh/recursion>

## ✅ 检查清单

完成练习后，检查以下几点：

- [ ] 理解了模板的每个部分
- [ ] 能够识别问题类型（子集/组合/排列）
- [ ] 能够正确设置终止条件
- [ ] 能够正确使用 `start` 或 `used`
- [ ] 能够正确实现回溯
- [ ] 能够添加适当的剪枝
- [ ] 能够处理重复元素的情况
- [ ] 能够优化时间和空间复杂度
