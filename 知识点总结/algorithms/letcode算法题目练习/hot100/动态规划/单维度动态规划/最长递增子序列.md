# 最长不下降子序列（Longest Non-decreasing Subsequence）

## 题目描述

给定一个长度为 n 的序列 A，找到一个最长的子序列 C，使得 C 的每个元素都不小于前一个元素（即非递减）。

**注意**：子序列不要求连续，只需要保持相对顺序即可。

### 示例

**示例 1：**

```text
输入：A = [10, 9, 2, 5, 3, 7, 101, 18]
输出：[2, 3, 7, 18] 或 [2, 5, 7, 18]
解释：最长不下降子序列的长度为 4
```

**示例 2：**

```text
输入：A = [1, 3, 2, 4, 5]
输出：[1, 2, 4, 5] 或 [1, 3, 4, 5]
解释：最长不下降子序列的长度为 4
```

**示例 3：**

```text
输入：A = [5, 5, 5, 5, 5]
输出：[5, 5, 5, 5, 5]
长度为 1
解释：所有元素都相等，整个序列都是不下降的
```

## 算法思路

### 动态规划解法

这是一个经典的动态规划问题。核心思想是：对于每个位置 i，我们考虑所有可能的前驱位置 j（j < i），如果 A[j] <= A[i]，那么可以将 A[i] 接在以 A[j] 结尾的最长不下降子序列后面。

### 状态定义

定义一维数组 `dp`，其中：

- `dp[i]` 表示以 `A[i]` 结尾的最长不下降子序列的长度

### 状态转移方程

对于每个位置 i（从 1 到 n-1）：

- 初始化：`dp[i] = 1`（每个元素本身可以作为一个长度为 1 的子序列）
- 对于所有 j（从 0 到 i-1）：
  - 如果 `A[j] <= A[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`
  - 这表示：如果 A[j] 可以接在 A[i] 前面，那么以 A[i] 结尾的最长不下降子序列长度至少是 `dp[j] + 1`

### 时间复杂度

- **时间复杂度**：O(n²)，其中 n 是序列的长度
  - 外层循环遍历 n 个元素
  - 内层循环对于每个元素最多遍历 i 次
- **空间复杂度**：O(n)，用于存储 dp 数组

## 代码实现

### 方法一：只求最长递增子序列的长度

```javascript
/**
 * 求最长不下降子序列的长度
 * @param {number[]} A 输入序列
 * @return {number} 最长不下降子序列的长度
 */
function lengthOfLNDS(A) {
    const n = A.length;
    // 边界情况：空数组返回 0
    if (n === 0) return 0;
    
    // dp[i] 表示以 A[i] 结尾的最长不下降子序列的长度
    // 初始化为 1，因为每个元素本身可以作为一个长度为 1 的子序列
    const dp = new Array(n).fill(1);
    
    // 外层循环：遍历数组中的每个元素
    for (let i = 1; i < n; i++) {
        // 内层循环：检查 A[i] 之前的所有元素
        for (let j = 0; j < i; j++) {
            // 如果 A[j] < A[i]，说明 A[i] 可以接在以 A[j] 结尾的子序列后面
            if (A[j] < A[i]) {
                // 更新 dp[i]：取当前值和 dp[j] + 1 的较大值
                // dp[j] + 1 表示将 A[i] 接在以 A[j] 结尾的子序列后面
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    // 返回 dp 数组中的最大值，即整个序列的最长不下降子序列长度
    return Math.max(...dp);
}

// 测试示例
const A1 = [10, 9, 2, 5, 3, 7, 101, 18];
console.log(lengthOfLNDS(A1)); // 输出: 4

const A2 = [1, 3, 2, 4, 5];
console.log(lengthOfLNDS(A2)); // 输出: 4

const A3 = [5, 5, 5, 5, 5];
console.log(lengthOfLNDS(A3)); // 输出: 5
```

### 方法二：求最长不下降子序列本身（回溯构造）

```javascript
/**
 * 求最长不下降子序列本身
 * @param {number[]} A 输入序列
 * @return {number[]} 最长不下降子序列
 */
function longestNonDecreasingSubsequence(A) {
    const n = A.length;
    // 边界情况：空数组返回空数组
    if (n === 0) return [];
    
    // dp[i] 表示以 A[i] 结尾的最长不下降子序列的长度
    const dp = new Array(n).fill(1);
    
    // 第一步：填充 DP 数组
    // 外层循环：遍历数组中的每个元素
    for (let i = 1; i < n; i++) {
        // 内层循环：检查 A[i] 之前的所有元素
        for (let j = 0; j < i; j++) {
            // 如果 A[j] <= A[i]，说明 A[i] 可以接在以 A[j] 结尾的子序列后面
            if (A[j] <= A[i]) {
                // 更新 dp[i]：取当前值和 dp[j] + 1 的较大值
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    // 第二步：找到最长不下降子序列的长度
    const maxLength = Math.max(...dp);
    
    // 第三步：回溯构造最长不下降子序列
    // 从后向前遍历，找到构成最长子序列的元素
    const result = [];
    let currentLength = maxLength; // 当前需要找到的子序列长度
    
    // 从数组末尾开始向前遍历
    for (let i = n - 1; i >= 0; i--) {
        // 如果当前元素的 dp 值等于当前需要的长度
        // 说明这个元素是构成最长子序列的一部分
        if (dp[i] === currentLength) {
            // 将元素添加到结果数组的开头（因为是从后向前遍历）
            result.unshift(A[i]);
            // 减少当前需要的长度，继续寻找下一个元素
            currentLength--;
            
            // 如果已经找到所有元素，提前退出
            if (currentLength === 0) break;
        }
    }
    
    return result;
}

// 测试示例
const A1 = [10, 9, 2, 5, 3, 7, 101, 18];
console.log(longestNonDecreasingSubsequence(A1)); 
// 输出: [2, 3, 7, 18] 或 [2, 5, 7, 18]（可能有多个解）

const A2 = [1, 3, 2, 4, 5];
console.log(longestNonDecreasingSubsequence(A2)); 
// 输出: [1, 2, 4, 5] 或 [1, 3, 4, 5]（可能有多个解）

const A3 = [5, 5, 5, 5, 5];
console.log(longestNonDecreasingSubsequence(A3)); 
// 输出: [5, 5, 5, 5, 5]
```

### 方法三：优化版本（记录前驱节点，更准确地回溯）

```javascript
/**
 * 优化版本：记录前驱节点，可以更准确地回溯构造子序列
 * @param {number[]} A 输入序列
 * @return {number[]} 最长不下降子序列
 */
function longestNonDecreasingSubsequenceOptimized(A) {
    const n = A.length;
    if (n === 0) return [];
    
    // dp[i] 表示以 A[i] 结尾的最长不下降子序列的长度
    const dp = new Array(n).fill(1);
    // prev[i] 记录以 A[i] 结尾的最长不下降子序列中，A[i] 的前驱节点索引
    // 如果 prev[i] = -1，表示 A[i] 是子序列的第一个元素
    const prev = new Array(n).fill(-1);
    
    // 填充 DP 数组和 prev 数组
    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (A[j] <= A[i]) {
                // 如果找到更长的子序列，更新 dp 和 prev
                if (dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    prev[i] = j; // 记录前驱节点
                }
            }
        }
    }
    
    // 找到最长子序列的结束位置
    let maxIndex = 0;
    for (let i = 1; i < n; i++) {
        if (dp[i] > dp[maxIndex]) {
            maxIndex = i;
        }
    }
    
    // 通过 prev 数组回溯构造最长不下降子序列
    const result = [];
    let currentIndex = maxIndex;
    
    // 从最长子序列的末尾开始，沿着 prev 指针向前回溯
    while (currentIndex !== -1) {
        result.unshift(A[currentIndex]);
        currentIndex = prev[currentIndex];
    }
    
    return result;
}

// 测试示例
const A1 = [10, 9, 2, 5, 3, 7, 101, 18];
console.log(longestNonDecreasingSubsequenceOptimized(A1)); 
// 输出: [2, 3, 7, 18]（更准确的解）
```

## 算法详解

### 步骤说明

1. **初始化 DP 数组**
   - 创建一个大小为 n 的数组 `dp`，并初始化为 1
   - 因为每个元素本身可以作为一个长度为 1 的子序列

2. **填充 DP 数组**
   - 对于每个位置 `i`（从 1 开始），遍历所有位置 `j`（从 0 到 i-1）
   - 如果 `A[j] <= A[i]`，说明 `A[i]` 可以接在以 `A[j]` 结尾的子序列后面
   - 更新 `dp[i] = max(dp[i], dp[j] + 1)`

3. **找到最长子序列的长度**
   - 遍历 `dp` 数组，找到最大值，即为最长不下降子序列的长度

4. **构造最长不下降子序列（可选）**
   - 从后向前遍历数组，找到 `dp[i]` 等于当前长度的元素
   - 将其加入结果序列，同时减少当前长度
   - 或者使用 `prev` 数组记录前驱节点，更准确地回溯

### 关键点理解

- **为什么是 `A[j] <= A[i]`？**
  - 因为题目要求"不下降"（非递减），所以允许相等的情况
  - 如果是"严格递增"子序列，则应该是 `A[j] < A[i]`

- **为什么从后向前回溯？**
  - 因为我们需要找到构成最长子序列的所有元素
  - 从后向前可以保证找到的是完整的子序列
  - 使用 `unshift` 将元素添加到数组开头，保持正确的顺序

- **为什么可能有多个解？**
  - 因为可能存在多个相同长度的不下降子序列
  - 例如：[2, 3, 7, 18] 和 [2, 5, 7, 18] 都是 [10, 9, 2, 5, 3, 7, 101, 18] 的最长不下降子序列

## 与最长递增子序列的区别

| 特性 | 最长递增子序列 (LIS) | 最长不下降子序列 (LNDS) |
|------|---------------------|------------------------|
| 条件 | `A[j] < A[i]`（严格递增） | `A[j] <= A[i]`（非递减） |
| 允许相等 | 否 | 是 |
| 示例 | [1, 2, 3] 是 [1, 2, 2, 3] 的 LIS | [1, 2, 2, 3] 是 [1, 2, 2, 3] 的 LNDS |

## 应用场景

- 股票价格分析：找到价格不下降的最长时期
- 数据压缩：找到可以合并的连续非递减数据段
- 序列分析：在生物信息学中分析 DNA 序列
- 游戏开发：路径规划中的非递减路径查找
