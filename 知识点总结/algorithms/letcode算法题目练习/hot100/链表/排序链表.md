# 排序链表

## 题目描述

给你链表的头结点 `head`，请将其按升序排列并返回排序后的链表。

## 解题思路

使用**归并排序**的思想：

1. **分割阶段**：将链表不断分割，直到每个部分都是单个节点
2. **合并阶段**：将有序的单个节点合并成有序链表

## 代码实现

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */

/**
 * 合并两个有序链表
 * @param {ListNode} listA - 第一个有序链表
 * @param {ListNode} listB - 第二个有序链表
 * @return {ListNode} 合并后的有序链表
 */
function mergeTwoList(listA, listB) {
    // 创建虚拟头节点，简化边界处理
    let dummyHead = new ListNode()
    let cur = dummyHead  // 当前指针，用于构建新链表
    
    // 同时遍历两个链表，比较节点值
    while (listA && listB) {
        if (listA.val < listB.val) {
            // listA 的节点值更小，将其连接到结果链表
            cur.next = listA
            listA = listA.next  // listA 指针后移
        } else {
            // listB 的节点值更小或相等，将其连接到结果链表
            cur.next = listB
            listB = listB.next  // listB 指针后移
        }
        cur = cur.next  // 结果链表指针后移
    }
    
    // 将剩余的非空链表连接到结果链表末尾
    if (listA) {
        cur.next = listA
    }
    if (listB) {
        cur.next = listB
    }
    
    // 返回虚拟头节点的下一个节点（真正的头节点）
    return dummyHead.next
}

/**
 * 递归排序链表（归并排序）
 * @param {ListNode} head - 链表头节点
 * @param {ListNode} tail - 链表尾边界（不包含在排序范围内）
 * @return {ListNode} 排序后的链表头节点
 */
function toSort(head, tail) {
    // 边界条件：空链表直接返回
    if (head == null) return head
    
    // 关键判断：是否已经拆分为单个节点？
    // head.next == tail 表示当前链表段只有一个节点
    // 例如：toSort(节点A, 节点B) 且 节点A.next == 节点B
    // 说明只有节点A需要排序，节点B是边界（不参与排序）
    if (head.next == tail) {
        // 单个节点本身就是有序的，无需再分割
        head.next = null  // 断开连接，避免循环引用
        return head       // 返回单个节点（已有序）
    }
    
    // 使用快慢指针找到链表中点
    let slow = head  // 慢指针，最终指向中点
    let fast = head  // 快指针，每次移动两步
    
    // 快指针移动到 tail 时，慢指针正好在中点
    while (fast !== tail) {
        slow = slow.next      // 慢指针移动一步
        fast = fast.next      // 快指针移动一步
        if (fast !== tail) {
            fast = fast.next  // 快指针再移动一步（总共两步）
        }
    }
    
    let mid = slow  // mid 是中点节点
    
    // 递归分割：继续拆分左右两部分，直到每个部分都是单个节点
    // 然后合并两个有序链表
    return mergeTwoList(
        toSort(head, mid),  // 递归排序左半部分 [head, mid)
        toSort(mid, tail)   // 递归排序右半部分 [mid, tail)
    )
}

/**
 * 主函数：对链表进行排序
 * @param {ListNode} head - 链表头节点
 * @return {ListNode} 排序后的链表头节点
 */
var sortList = function(head) {
    // 调用递归排序函数，tail 设为 null（表示整个链表）
    return toSort(head, null)
};
```

## 关键点解析

### 1. `head.next == tail` 的逻辑

这是归并排序的**递归终止条件**，用于判断是否已经将链表拆分为单个节点。

**含义**：

- `head` 是当前链表段的起始节点
- `tail` 是链表段的结束边界（不包含在排序范围内）
- `head.next == tail` 表示 `head` 的下一个节点就是 `tail`，说明只有 `head` 这一个节点需要排序

**示例**：

```javascript
// 假设链表：1 -> 2 -> 3 -> 4 -> null

// 第一次调用：toSort(节点1, null)
// head.next = 节点2, tail = null
// head.next != tail，继续分割

// 递归到最底层：toSort(节点1, 节点2)
// head = 节点1
// head.next = 节点2
// tail = 节点2
// head.next == tail ✅ 成立！
// 说明只有节点1需要排序，节点2是边界
// 返回节点1（单个节点已有序）
```

### 2. 为什么要设置 `head.next = null`？

断开与后续节点的连接，避免在合并时产生循环引用或错误连接。

### 3. 快慢指针找中点

```javascript
// 快指针每次移动两步，慢指针每次移动一步
// 当快指针到达 tail 时，慢指针正好在中点

// 示例：链表 1 -> 2 -> 3 -> 4 -> null
// slow = 1, fast = 1
// 第1次：slow = 2, fast = 3
// 第2次：slow = 3, fast = null (tail)
// 中点 mid = 3
```

## 完整示例

### 示例 1：基本排序

```javascript
// 输入：4 -> 2 -> 1 -> 3 -> null
// 输出：1 -> 2 -> 3 -> 4 -> null

// 分割过程：
// 4 -> 2 -> 1 -> 3
// ↓
// 4 -> 2    和    1 -> 3
// ↓              ↓
// 4    2    和    1    3  ← 拆分为单个节点

// 合并过程：
// 4    2    1    3
// ↓    ↓    ↓    ↓
// 2 -> 4    1 -> 3
// ↓              ↓
// 1 -> 2 -> 3 -> 4  ← 最终有序链表
```

### 示例 2：执行流程

```javascript
// 输入链表：4 -> 2 -> 1 -> 3 -> null

// 调用 sortList(节点4)
// ↓
// toSort(节点4, null)
//   找到中点 mid = 节点1
//   ↓
//   toSort(节点4, 节点1)  // 左半部分：4 -> 2
//     找到中点 mid = 节点2
//     ↓
//     toSort(节点4, 节点2)  // 左半部分：4
//       head.next == 节点2 == tail ✅
//       返回 节点4
//     ↓
//     toSort(节点2, 节点1)  // 右半部分：2
//       head.next == 节点1 == tail ✅
//       返回 节点2
//     ↓
//     mergeTwoList(节点4, 节点2)
//       返回 2 -> 4
//   ↓
//   toSort(节点1, null)  // 右半部分：1 -> 3
//     找到中点 mid = 节点3
//     ↓
//     toSort(节点1, 节点3)  // 左半部分：1
//       head.next == 节点3 == tail ✅
//       返回 节点1
//     ↓
//     toSort(节点3, null)  // 右半部分：3
//       head.next == null == tail ✅
//       返回 节点3
//     ↓
//     mergeTwoList(节点1, 节点3)
//       返回 1 -> 3
//   ↓
//   mergeTwoList(2 -> 4, 1 -> 3)
//     返回 1 -> 2 -> 3 -> 4
```

## 时间复杂度

- **时间复杂度**：O(n log n)
  - 分割阶段：O(log n) 层递归
  - 每层合并：O(n)
  - 总时间：O(n log n)

- **空间复杂度**：O(log n)
  - 递归调用栈的深度为 O(log n)

## 总结

1. **分割阶段**：使用快慢指针找到中点，递归分割链表，直到每个部分都是单个节点
2. **终止条件**：`head.next == tail` 判断是否已拆分为单个节点
3. **合并阶段**：使用双指针合并两个有序链表
4. **关键技巧**：使用虚拟头节点简化边界处理，使用 `tail` 参数明确排序范围
