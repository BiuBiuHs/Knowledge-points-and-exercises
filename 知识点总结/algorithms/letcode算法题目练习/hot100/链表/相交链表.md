[链表相交 LeetCode](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)

双指针方法，用于判断两个链表是否相交，并找到相交的起始节点。让我们详细解释一下这个算法的逻辑，特别是当两个链表不相交时的情况。

### 代码解析

```javascript
var getIntersectionNode = function(headA, headB) {
    // p1 指向 A 链表头结点，p2 指向 B 链表头结点
    let p1 = headA, p2 = headB;
    while (p1 !== p2) {
        // p1 走一步，如果走到 A 链表末尾，转到 B 链表
        if (p1 === null) p1 = headB;
        else p1 = p1.next;
        // p2 走一步，如果走到 B 链表末尾，转到 A 链表
        //此时赋值的操作 就相当于调用 next
        if (p2 === null) p2 = headA;
        else p2 = p2.next;
    }
    return p1;
};
```

### 逻辑解释

1. **初始化指针**：
   - `p1` 指向链表 `A` 的头结点 `headA`。
   - `p2` 指向链表 `B` 的头结点 `headB`。

2. **循环条件**：
   - 循环继续，直到 `p1` 和 `p2` 相等。这可能是因为它们遇到了相同的节点（相交点），或者它们都走到了链表的末尾（`null`）。

3. **指针移动**：
   - `p1` 每次移动一步，如果 `p1` 到达链表 `A` 的末尾（`p1 === null`），则将 `p1` 重置为链表 `B` 的头结点 `headB`。
   - `p2` 每次移动一步，如果 `p2` 到达链表 `B` 的末尾（`p2 === null`），则将 `p2` 重置为链表 `A` 的头结点 `headA`。

### 两个链表不相交的情况

当两个链表不相交时，`p1` 和 `p2` 最终都会走到各自的末尾（`null`），并且在第二次遍历中，它们会同时变为 `null`，从而结束循环。

### 详细步骤

1. **初始状态**：
   - `p1` 指向 `headA`。
   - `p2` 指向 `headB`。

2. **第一次遍历**：
   - `p1` 和 `p2` 各自沿着链表 `A` 和 `B` 移动。
   - 如果 `p1` 到达链表 `A` 的末尾，`p1` 会被重置为 `headB`。
   - 如果 `p2` 到达链表 `B` 的末尾，`p2` 会被重置为 `headA`。

3. **第二次遍历**：
   - `p1` 和 `p2` 继续移动，但这次它们分别沿着链表 `B` 和 `A` 移动。
   - 最终，`p1` 和 `p2` 都会到达链表的末尾（`null`），此时 `p1 === p2`，循环结束。

### 结果

- 如果两个链表相交，`p1` 和 `p2` 会在相交点相遇，返回该节点。
- 如果两个链表不相交，`p1` 和 `p2` 最终都会变成 `null`，循环结束，返回 `null`。

### 示例

假设链表 `A` 和链表 `B` 不相交：

- `A: 1 -> 2 -> 3 -> null`
- `B: 4 -> 5 -> 6 -> null`

1. **初始状态**：
   - `p1` 指向 `1`。
   - `p2` 指向 `4`。

2. **第一次遍历**：
   - `p1` 依次移动到 `2`、`3`，然后重置为 `4`。
   - `p2` 依次移动到 `5`、`6`，然后重置为 `1`。

3. **第二次遍历**：
   - `p1` 依次移动到 `5`、`6`，然后变成 `null`。
   - `p2` 依次移动到 `2`、`3`，然后变成 `null`。

4. **循环结束**：
   - `p1` 和 `p2` 都为 `null`，返回 `null`。

### 总结

当两个链表不相交时，`p1` 和 `p2` 最终都会变成 `null`，循环结束，返回 `null`。因此，不会造成死循环，`p1` 的值最终会是 `null`。
