// https://leetcode.cn/problems/gas-station/description/
// 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

// 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

// 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

// 示例 1:

// 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
// 输出: 3
// 解释:
// 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
// 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
// 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
// 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
// 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
// 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
// 因此，3 可为起始索引。
// 示例 2:

// 输入: gas = [2,3,4], cost = [3,4,3]
// 输出: -1
// 解释:
// 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
// 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
// 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
// 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
// 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
// 因此，无论怎样，你都不可能绕环路行驶一周。

/**题解

那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。

局部最优可以推出全局最优，找不出反例，试试贪心！

**/
/**贪心算法
 * @param {number[]} gas - 每个加油站的汽油量
 * @param {number[]} cost - 从一个加油站到下一个加油站所需的汽油量
 * @return {number} - 如果可以完成一圈，返回起始加油站的索引；否则返回 -1
 */
var canCompleteCircuit = function (gas, cost) {
	let totalSum = 0; // 用于记录所有加油站的汽油净剩余量
	let curSum = 0; // 用于记录当前路径的汽油净剩余量
	let statePosition = 0; // 用于记录起始加油站的索引

	// 遍历每个加油站
	for (let i = 0; i < gas.length; i++) {
		// 计算当前加油站的汽油净剩余量
		curSum += gas[i] - cost[i];
		totalSum += gas[i] - cost[i];

		// 如果当前路径的汽油净剩余量小于 0，说明从起始位置到当前加油站无法完成一圈
		if (curSum < 0) {
			// 更新起始位置为下一个加油站
			statePosition = i + 1;
			// 重置当前路径的汽油净剩余量
			curSum = 0;
		}
	}

	// 如果所有加油站的汽油净剩余量小于 0，说明无法完成一圈
	if (totalSum < 0) {
		return -1;
	}

	// 返回起始加油站的索引
	return statePosition;
};

//纯暴力解法

/**
 * @param {number[]} gas - 每个加油站的汽油量
 * @param {number[]} cost - 从一个加油站到下一个加油站所需的汽油量
 * @return {number} - 如果可以完成一圈，返回起始加油站的索引；否则返回 -1
 */
var canCompleteCircuit = function (gas, cost) {
	// 遍历每个加油站，尝试以每个加油站为起点
	for (let i = 0; i < cost.length; i++) {
		let rest = gas[i] - cost[i]; // 记录从起点 i 出发的剩余油量
		let index = (i + 1) % cost.length; // 下一个加油站的索引

		// 模拟从起点 i 出发，尝试行驶一圈
		while (rest > 0 && index !== i) {
			rest += gas[index] - cost[index]; // 更新剩余油量
			index = (index + 1) % cost.length; // 移动到下一个加油站
		}

		// 如果以 i 为起点跑一圈，剩余油量 >= 0，返回该起始位置
		if (rest >= 0 && index === i) {
			return i;
		}
	}

	// 如果无法完成一圈，返回 -1
	return -1;
};
