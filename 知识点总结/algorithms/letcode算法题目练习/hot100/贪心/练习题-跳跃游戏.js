/**
 * 55. 跳跃游戏
 * https://leetcode.cn/problems/jump-game/
 * 
 * 题目：给定一个非负整数数组 nums，你最初位于数组的第一个下标。
 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
 * 判断你是否能够到达最后一个下标。
 * 
 * 示例：
 * 输入：nums = [2,3,1,1,4]
 * 输出：true
 * 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
 * 
 * 输入：nums = [3,2,1,0,4]
 * 输出：false
 * 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0，所以永远不可能到达最后一个下标。
 * 
 * 提示：
 * - 1 <= nums.length <= 3 * 10^4
 * - 0 <= nums[i] <= 10^5
 */

/**
 * 方法1：贪心算法（维护最远可达位置）
 * 
 * 核心思想：
 * 1. 遍历数组，维护当前能够到达的最远位置
 * 2. 如果当前位置超过了最远可达位置，说明无法到达
 * 3. 更新最远可达位置：max(maxReach, i + nums[i])
 * 
 * 贪心策略：
 * - 每一步都尽可能跳得远（贪心选择）
 * - 如果能够到达当前位置，那么之前的所有位置都能到达
 */
var canJump = function(nums) {
    let maxReach = 0;  // 当前能够到达的最远位置
    
    for (let i = 0; i < nums.length; i++) {
        // 如果当前位置超过了最远可达位置，说明无法到达
        if (i > maxReach) {
            return false;
        }
        
        // 更新最远可达位置
        // 当前位置 i 可以到达的最远位置是 i + nums[i]
        maxReach = Math.max(maxReach, i + nums[i]);
        
        // 如果已经能够到达最后一个位置，提前返回
        if (maxReach >= nums.length - 1) {
            return true;
        }
    }
    
    return true;
};

// 测试
console.log("=== 跳跃游戏问题 ===");
console.log("输入：nums = [2,3,1,1,4]");
console.log("输出：", canJump([2,3,1,1,4]));
console.log("期望：true");

console.log("\n输入：nums = [3,2,1,0,4]");
console.log("输出：", canJump([3,2,1,0,4]));
console.log("期望：false");

/**
 * ============================================
 * 算法执行过程详解（以 nums = [2,3,1,1,4] 为例）
 * ============================================
 * 
 * 数组：nums = [2, 3, 1, 1, 4]
 * 索引：       0  1  2  3  4
 * 
 * 执行过程：
 * 
 * i = 0:
 *   i = 0 <= maxReach = 0 ✅
 *   maxReach = max(0, 0 + 2) = 2
 * 
 * i = 1:
 *   i = 1 <= maxReach = 2 ✅
 *   maxReach = max(2, 1 + 3) = 4
 *   maxReach = 4 >= 4 ✅ 提前返回 true
 * 
 * 结果：true
 * 
 * 
 * 以 nums = [3,2,1,0,4] 为例：
 * 
 * i = 0:
 *   i = 0 <= maxReach = 0 ✅
 *   maxReach = max(0, 0 + 3) = 3
 * 
 * i = 1:
 *   i = 1 <= maxReach = 3 ✅
 *   maxReach = max(3, 1 + 2) = 3
 * 
 * i = 2:
 *   i = 2 <= maxReach = 3 ✅
 *   maxReach = max(3, 2 + 1) = 3
 * 
 * i = 3:
 *   i = 3 <= maxReach = 3 ✅
 *   maxReach = max(3, 3 + 0) = 3
 * 
 * i = 4:
 *   i = 4 > maxReach = 3 ❌
 *   返回 false
 */

/**
 * ============================================
 * 贪心策略证明
 * ============================================
 * 
 * 【贪心选择性质】
 * 
 * 假设在位置 i，我们能够到达的最远位置是 maxReach。
 * 
 * 如果 maxReach >= nums.length - 1，那么一定可以到达最后一个位置。
 * 
 * 如果 maxReach < nums.length - 1，我们需要继续前进。
 * 在位置 i，我们可以选择跳 1, 2, ..., nums[i] 步。
 * 
 * 贪心策略：总是选择能够到达最远位置的跳法。
 * 
 * 证明：如果存在一个解，其中在位置 i 跳了 k 步（k < nums[i]），
 * 那么跳 nums[i] 步一定不会更差，因为：
 * - 跳 k 步能到达的位置，跳 nums[i] 步也能到达
 * - 跳 nums[i] 步还能到达更远的位置
 * 
 * 所以贪心选择是正确的。
 * 
 * 【最优子结构】
 * 
 * 如果从位置 0 能够到达位置 i，那么从位置 0 到达位置 i 的问题
 * 和从位置 i 到达最后位置的问题具有相同的结构。
 */

/**
 * ============================================
 * 方法2：动态规划（对比）
 * ============================================
 * 
 * 动态规划思路：
 * - dp[i] 表示能否到达位置 i
 * - dp[0] = true
 * - dp[i] = dp[j] && (j + nums[j] >= i) for some j < i
 * 
 * 时间复杂度：O(n²)
 * 空间复杂度：O(n)
 * 
 * 贪心算法更优：
 * - 时间复杂度：O(n)
 * - 空间复杂度：O(1)
 */
var canJumpDP = function(nums) {
    let n = nums.length;
    let dp = new Array(n).fill(false);
    dp[0] = true;
    
    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (dp[j] && j + nums[j] >= i) {
                dp[i] = true;
                break;
            }
        }
    }
    
    return dp[n - 1];
};

/**
 * ============================================
 * 时间复杂度与空间复杂度
 * ============================================
 * 
 * 时间复杂度：O(n)
 * - 只需要遍历一次数组
 * 
 * 空间复杂度：O(1)
 * - 只使用了常数额外空间
 */

