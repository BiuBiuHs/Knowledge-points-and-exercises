/**
 * 455. 分发饼干
 * https://leetcode.cn/problems/assign-cookies/
 *
 * 题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。
 * 但是，每个孩子最多只能给一块饼干。
 *
 * 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
 * 并且每块饼干 j，都有一个尺寸 s[j]。
 * 如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i，这个孩子会得到满足。
 * 你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
 *
 * 示例：
 * 输入：g = [1,2,3], s = [1,1]
 * 输出：1
 * 解释：你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
 * 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
 * 所以你应该输出1。
 *
 * 输入：g = [1,2], s = [1,2,3]
 * 输出：2
 * 解释：你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
 * 你拥有的饼干数量和尺寸都足以让所有孩子满足。
 * 所以你应该输出2.
 *
 * 提示：
 * - 1 <= g.length <= 3 * 10^4
 * - 0 <= s.length <= 3 * 10^4
 * - 1 <= g[i], s[j] <= 2^31 - 1
 */

/**
 * 方法1：贪心算法（排序 + 双指针）
 *
 * 核心思想：
 * 1. 将孩子和饼干都按从小到大排序
 * 2. 用最小的饼干满足胃口最小的孩子（贪心策略）
 * 3. 如果当前饼干不能满足当前孩子，尝试更大的饼干
 *
 * 贪心策略证明：
 * - 如果最小的饼干不能满足胃口最小的孩子，那么它也不能满足其他孩子
 * - 如果最小的饼干能满足胃口最小的孩子，那么用它满足这个孩子是最优的
 *   因为如果不用它，可能需要用更大的饼干，浪费了资源
 */
var findContentChildren = function (g, s) {
	// 1. 排序：将孩子和饼干都按从小到大排序
	g.sort((a, b) => a - b);
	s.sort((a, b) => a - b);

	let count = 0; // 满足的孩子数量
	let i = 0; // 孩子指针
	let j = 0; // 饼干指针

	// 2. 贪心分配：用最小的饼干满足胃口最小的孩子
	while (i < g.length && j < s.length) {
		if (s[j] >= g[i]) {
			// 当前饼干可以满足当前孩子
			count++;
			i++; // 孩子指针后移
		}
		// 无论是否满足，饼干指针都要后移
		// 如果满足：当前饼干已使用
		// 如果不满足：当前饼干太小，需要更大的饼干
		j++;
	}

	return count;
};

// 测试
console.log("=== 分发饼干问题 ===");
console.log("输入：g = [1,2,3], s = [1,1]");
console.log("输出：", findContentChildren([1, 2, 3], [1, 1]));
console.log("期望：1");

console.log("\n输入：g = [1,2], s = [1,2,3]");
console.log("输出：", findContentChildren([1, 2], [1, 2, 3]));
console.log("期望：2");

/**
 * ============================================
 * 算法执行过程详解（以 g = [1,2,3], s = [1,1] 为例）
 * ============================================
 *
 * 排序后：
 * g = [1, 2, 3]  (孩子胃口值)
 * s = [1, 1]     (饼干尺寸)
 *
 * 执行过程：
 *
 * 初始：i = 0, j = 0, count = 0
 *
 * 第1次循环：
 *   s[0] = 1 >= g[0] = 1 ✅
 *   count = 1, i = 1, j = 1
 *
 * 第2次循环：
 *   s[1] = 1 < g[1] = 2 ❌
 *   count = 1, i = 1, j = 2
 *
 * j = 2 >= s.length，循环结束
 *
 * 最终结果：count = 1
 */

/**
 * ============================================
 * 贪心策略证明
 * ============================================
 *
 * 【贪心选择性质】
 *
 * 假设存在一个最优解，其中最小的饼干 s[0] 没有分配给胃口最小的孩子 g[0]。
 *
 * 情况1：s[0] >= g[0]
 *   - 如果 s[0] 分配给了 g[k] (k > 0)
 *   - 那么可以用 s[0] 替换分配给 g[0] 的饼干 s[j]
 *   - 因为 s[0] <= s[j]，所以 s[j] >= g[k] 一定成立
 *   - 这样得到的解不会更差，所以贪心选择是正确的
 *
 * 情况2：s[0] < g[0]
 *   - s[0] 无法满足任何孩子，应该跳过
 *   - 贪心策略也是正确的
 *
 * 【最优子结构】
 *
 * 如果当前分配是最优的，那么剩余的孩子和饼干的最优分配
 * 加上当前分配，就是全局最优解。
 */

/**
 * ============================================
 * 时间复杂度与空间复杂度
 * ============================================
 *
 * 时间复杂度：O(n log n + m log m)
 * - 排序：O(n log n) + O(m log m)
 * - 遍历：O(n + m)
 * - 总时间：O(n log n + m log m)
 *
 * 空间复杂度：O(1)
 * - 只使用了常数额外空间
 */
