# 贪心算法大纲

## 什么是贪心算法？

贪心算法（Greedy Algorithm）是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。

### 核心思想

**局部最优 → 全局最优**

- 每一步都做出当前看起来最好的选择
- 不回溯，不重新考虑已做出的选择
- 希望通过局部最优达到全局最优

## 贪心算法的特点

### 优点
- ✅ 实现简单，代码简洁
- ✅ 时间复杂度通常较低
- ✅ 空间复杂度通常为 O(1)

### 缺点
- ❌ 不能保证得到全局最优解
- ❌ 需要证明贪心策略的正确性
- ❌ 适用场景有限

## 贪心算法的适用条件

### 1. 贪心选择性质（Greedy Choice Property）

**定义**：可以通过做出局部最优选择来构造全局最优解。

**关键**：每一步的最优选择不依赖于未来的选择，也不依赖于子问题的解。

### 2. 最优子结构（Optimal Substructure）

**定义**：问题的最优解包含子问题的最优解。

**关键**：如果一个问题的最优解可以通过子问题的最优解来构造，那么这个问题具有最优子结构。

## 贪心算法 vs 动态规划

| 特性 | 贪心算法 | 动态规划 |
|------|---------|---------|
| **选择方式** | 每一步都做局部最优选择 | 考虑所有可能的子问题 |
| **回溯** | 不回溯 | 可能需要回溯 |
| **时间复杂度** | 通常 O(n) 或 O(n log n) | 通常 O(n²) 或更高 |
| **空间复杂度** | 通常 O(1) | 通常 O(n) 或更高 |
| **适用场景** | 满足贪心选择性质的问题 | 具有重叠子问题的问题 |
| **保证最优** | 需要证明 | 保证最优 |

## 贪心算法的解题步骤

### 步骤1：分析问题

1. 理解问题的目标
2. 识别可以做的选择
3. 确定每一步的"最优"标准

### 步骤2：设计贪心策略

1. 确定每一步如何选择
2. 考虑边界情况
3. 验证策略的合理性

### 步骤3：证明贪心策略

1. **贪心选择性质**：证明局部最优可以导致全局最优
2. **最优子结构**：证明问题具有最优子结构
3. **反证法**：假设存在更优解，推导矛盾

### 步骤4：实现算法

1. 根据策略编写代码
2. 处理边界情况
3. 优化时间和空间复杂度

## 常见贪心问题类型

### 1. 区间问题

- **区间调度**：选择不重叠的区间
- **区间覆盖**：用最少的区间覆盖目标区间
- **区间合并**：合并重叠的区间

**典型题目**：
- 56. 合并区间
- 435. 无重叠区间
- 452. 用最少数量的箭引爆气球

### 2. 分配问题

- **分配资源**：将资源分配给任务
- **负载均衡**：平衡负载

**典型题目**：
- 455. 分发饼干
- 135. 分发糖果

### 3. 跳跃问题

- **能否到达**：判断能否到达终点
- **最少步数**：到达终点的最少步数

**典型题目**：
- 55. 跳跃游戏
- 45. 跳跃游戏 II

### 4. 买卖股票问题

- **一次交易**：最多买卖一次
- **多次交易**：可以多次买卖
- **带手续费**：考虑交易成本

**典型题目**：
- 121. 买卖股票的最佳时机
- 122. 买卖股票的最佳时机 II
- 714. 买卖股票的最佳时机含手续费

### 5. 字符串问题

- **字符重排**：重新排列字符
- **删除字符**：删除某些字符

**典型题目**：
- 767. 重构字符串
- 316. 去除重复字母

### 6. 其他问题

- **加油站问题**：能否绕一圈
- **分糖果问题**：满足条件的最少数量
- **任务调度**：安排任务执行顺序

## 贪心算法的证明方法

### 方法1：交换论证法

假设存在一个最优解，通过交换操作将其转换为贪心解，证明贪心解不劣于最优解。

### 方法2：数学归纳法

证明对于任意规模的问题，贪心策略都能得到最优解。

### 方法3：反证法

假设贪心解不是最优解，推导出矛盾。

### 方法4：剪枝法

证明任何非贪心的选择都不会得到更好的结果。

## 贪心算法的实现模板

### 模板1：区间问题

```javascript
function greedyInterval(intervals) {
    // 1. 排序（通常按结束时间或开始时间）
    intervals.sort((a, b) => {
        // 根据问题选择排序方式
        return a[1] - b[1]; // 按结束时间排序
    });
    
    let count = 0;
    let prevEnd = -Infinity;
    
    // 2. 遍历区间
    for (let interval of intervals) {
        if (interval[0] >= prevEnd) {
            // 3. 贪心选择：选择当前区间
            count++;
            prevEnd = interval[1];
        }
    }
    
    return count;
}
```

### 模板2：分配问题

```javascript
function greedyAssign(tasks, resources) {
    // 1. 排序
    tasks.sort((a, b) => a - b);
    resources.sort((a, b) => a - b);
    
    let count = 0;
    let i = 0, j = 0;
    
    // 2. 贪心分配
    while (i < tasks.length && j < resources.length) {
        if (resources[j] >= tasks[i]) {
            // 可以分配
            count++;
            i++;
        }
        j++;
    }
    
    return count;
}
```

### 模板3：跳跃问题

```javascript
function greedyJump(nums) {
    let maxReach = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (i > maxReach) {
            // 无法到达当前位置
            return false;
        }
        // 更新最远可达位置
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    
    return true;
}
```

## 学习路径

### 入门级（理解贪心思想）

1. **455. 分发饼干** ⭐
   - 最简单的贪心问题
   - 理解"局部最优"的概念

2. **121. 买卖股票的最佳时机** ⭐
   - 一次交易问题
   - 理解"贪心选择"的含义

### 进阶级（掌握常见模式）

3. **55. 跳跃游戏** ⭐⭐
   - 判断能否到达
   - 理解"最远可达"的贪心策略

4. **45. 跳跃游戏 II** ⭐⭐
   - 最少步数问题
   - 理解"贪心选择"的优化

5. **56. 合并区间** ⭐⭐
   - 区间问题
   - 理解排序 + 贪心的组合

### 高级（复杂贪心问题）

6. **435. 无重叠区间** ⭐⭐⭐
   - 区间调度问题
   - 理解贪心策略的证明

7. **452. 用最少数量的箭引爆气球** ⭐⭐⭐
   - 区间覆盖问题
   - 理解贪心选择的技巧

8. **135. 分发糖果** ⭐⭐⭐
   - 双向贪心
   - 理解"左右遍历"的策略

## 常见错误

### 错误1：没有排序

```javascript
// ❌ 错误：没有排序
function greedy(nums) {
    for (let num of nums) {
        // 处理逻辑
    }
}

// ✅ 正确：先排序
function greedy(nums) {
    nums.sort((a, b) => a - b);
    for (let num of nums) {
        // 处理逻辑
    }
}
```

### 错误2：贪心策略错误

```javascript
// ❌ 错误：每次都选择最大的
function greedy(nums) {
    let result = [];
    while (nums.length > 0) {
        let max = Math.max(...nums);
        result.push(max);
        // ...
    }
}

// ✅ 正确：根据问题设计合适的策略
function greedy(nums) {
    // 根据具体问题设计策略
}
```

### 错误3：没有处理边界情况

```javascript
// ❌ 错误：没有处理空数组
function greedy(nums) {
    let sum = 0;
    for (let num of nums) {
        sum += num;
    }
    return sum;
}

// ✅ 正确：处理边界情况
function greedy(nums) {
    if (nums.length === 0) return 0;
    let sum = 0;
    for (let num of nums) {
        sum += num;
    }
    return sum;
}
```

## 总结

1. **贪心算法的核心**：局部最优 → 全局最优
2. **适用条件**：贪心选择性质 + 最优子结构
3. **常见类型**：区间问题、分配问题、跳跃问题、买卖股票等
4. **解题步骤**：分析问题 → 设计策略 → 证明策略 → 实现算法
5. **关键技巧**：排序、双指针、维护最值

## 参考资源

- [LeetCode 贪心算法专题](https://leetcode.cn/tag/greedy/)
- 《算法导论》第16章：贪心算法
- 《算法竞赛进阶指南》第1章：贪心算法

