// 链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
// 题目：二叉树的最近公共祖先
//
// 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
//
// 百度百科中最近公共祖先的定义为：
// "对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，
// 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。"
//
// 示例 1：
// 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
// 输出：3
// 解释：节点 5 和节点 1 的最近公共祖先是节点 3。
//
// 示例 2：
// 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
// 输出：5
// 解释：节点 5 和节点 4 的最近公共祖先是节点 5。
// 因为根据定义最近公共祖先节点可以为节点本身。
//
// 示例 3：
// 输入：root = [1,2], p = 1, q = 2
// 输出：1
//
// 提示：
// - 树中节点数目在范围 [2, 10^5] 内
// - -10^9 <= Node.val <= 10^9
// - 所有 Node.val 互不相同
// - p != q
// - p 和 q 均存在于给定的二叉树中

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * 算法思路：递归 + 后序遍历
 *
 * 核心思想：
 * 1. 如果当前节点是 null，返回 null
 * 2. 如果当前节点是 p 或 q，返回当前节点（找到了其中一个目标节点）
 * 3. 递归查找左子树和右子树
 * 4. 根据左右子树的结果判断：
 *    - 如果左右子树都找到了节点（都不为 null），说明当前节点就是最近公共祖先
 *    - 如果只有一边找到了，返回找到的那一边的结果
 *    - 如果两边都没找到，返回 null
 *
 * 时间复杂度：O(n)，其中 n 是二叉树的节点数
 * 空间复杂度：O(h)，其中 h 是二叉树的高度（递归栈的深度）
 *
 * @param {TreeNode} root 二叉树的根节点
 * @param {TreeNode} p 目标节点 p
 * @param {TreeNode} q 目标节点 q
 * @return {TreeNode} 最近公共祖先节点
 */
var lowestCommonAncestor = function (root, p, q) {
	// 情况 1：如果当前节点为空，返回 null
	// 这是递归的终止条件之一
	if (root == null) return root;

	// 情况 2：如果当前节点就是 p 或 q，直接返回当前节点
	// 这说明我们在当前路径上找到了目标节点之一
	// 注意：一个节点可以是它自己的祖先
	if (root == p || root == q) return root;

	// 情况 3：递归查找左子树和右子树
	// 在后序遍历中，我们先处理左右子树，再处理当前节点
	let left = lowestCommonAncestor(root.left, p, q);
	let right = lowestCommonAncestor(root.right, p, q);

	// 情况 4：如果左右子树都找到了节点（都不为 null）
	// 说明 p 和 q 分别位于当前节点的左右子树中
	// 那么当前节点就是它们的最近公共祖先
	if (left !== null && right !== null) return root;

	// 情况 5：如果只有右子树找到了节点
	// 说明 p 和 q 都在右子树中，返回右子树的结果
	if (left == null && right !== null) return right;

	// 情况 6：如果只有左子树找到了节点
	// 说明 p 和 q 都在左子树中，返回左子树的结果
	if (left !== null && right == null) {
		return left;
	} else {
		// 情况 7：如果左右子树都没找到（都为 null）
		// 说明当前子树中不包含 p 或 q，返回 null
		return null;
	}
};

// 简化版本：代码更简洁，逻辑相同
var lowestCommonAncestorSimplified = function (root, p, q) {
	// 如果当前节点为空，或者是 p 或 q，直接返回
	if (root == null || root == p || root == q) {
		return root;
	}

	// 递归查找左右子树
	let left = lowestCommonAncestorSimplified(root.left, p, q);
	let right = lowestCommonAncestorSimplified(root.right, p, q);

	// 如果左右子树都找到了，说明当前节点是最近公共祖先
	if (left !== null && right !== null) {
		return root;
	}

	// 否则返回非空的那一边，或者 null（如果都为空）
	return left !== null ? left : right;
};

// 算法详解：
//
// 示例分析（示例 1）：
// 树结构：
//        3
//      /   \
//     5     1
//    / \   / \
//   6   2 0   8
//      / \
//     7   4
//
// 查找节点 5 和节点 1 的最近公共祖先：
//
// 1. 从根节点 3 开始
//    - 递归左子树（节点 5）
//    - 递归右子树（节点 1）
//
// 2. 在左子树中查找：
//    - 节点 5 就是目标节点之一，返回节点 5
//
// 3. 在右子树中查找：
//    - 节点 1 就是目标节点之一，返回节点 1
//
// 4. 回到根节点 3：
//    - left = 节点 5（不为 null）
//    - right = 节点 1（不为 null）
//    - 因为左右都不为 null，所以节点 3 就是最近公共祖先
//
// 示例分析（示例 2）：
// 查找节点 5 和节点 4 的最近公共祖先：
//
// 1. 从根节点 3 开始
//    - 递归左子树（节点 5）
//    - 递归右子树（节点 1）
//
// 2. 在左子树中查找（递归到节点 5）：
//    - 节点 5 是目标节点之一（p），直接返回节点 5
//    - 注意：不会继续向下查找节点 4，因为代码中有判断：
//      if (root == p || root == q) return root;
//    - 这意味着如果当前节点就是目标节点，会立即返回，不再递归
//
// 3. 在右子树中查找（递归到节点 1）：
//    - 节点 1 不是目标节点，继续递归
//    - 左子树（节点 0）：返回 null
//    - 右子树（节点 8）：返回 null
//    - 节点 1 的 left = null, right = null
//    - 返回 null（右子树中没有找到目标节点）
//
// 4. 回到根节点 3：
//    - left = 节点 5（不为 null，找到了目标节点 p）
//    - right = null（右子树中没有找到目标节点）
//    - 因为只有一边返回非 null，返回 left，即节点 5
//
// 为什么节点 5 是 LCA？
// - 节点 5 本身就是目标节点之一（p）
// - 节点 4 在节点 5 的子树中（节点 5 -> 节点 2 -> 节点 4）
// - 根据定义，一个节点可以是它自己的祖先
// - 所以节点 5 是节点 5 和节点 4 的最近公共祖先
//
// 关键理解：
// - 如果当前节点是 p 或 q，直接返回，不再向下递归查找
//   这是因为一个节点可以是它自己的祖先，如果当前节点就是目标节点之一，
//   那么它可能就是 LCA（如果另一个目标节点在它的子树中）
// - 如果左右子树都返回了非 null 值，说明 p 和 q 分别在左右子树中，当前节点就是 LCA
// - 如果只有一边返回非 null，说明找到了一个目标节点（或两个都在那一边），
//   继续向上传递结果，让上层节点判断
// - 如果两边都是 null，说明当前子树中没有 p 或 q，返回 null
//
// 重要：当找到目标节点时立即返回，不会继续向下查找，这是算法的关键优化点
