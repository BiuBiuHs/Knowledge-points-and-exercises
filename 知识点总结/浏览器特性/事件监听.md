## 添加事件监听 


### addEventListener 

该方法接受三个参数。

* type：事件名称，大小写敏感。
* listener：监听函数。事件发生时，会调用该监听函数。
* useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为false（监听函数只在冒泡阶段被触发）。该参数可选。

参数注意事项：

* 第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象。
* 第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。
* capture：布尔值，表示该事件是否在捕获阶段触发监听函数。
* once：布尔值，表示监听函数是否只触发一次，然后就自动移除。
* passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。

特性：

    1.addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发
    2. 如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用removeEventListener方法手动去除）。


#### 2.直接在html元素上使用 on + 事件名称

### HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。

```
<body onload="doSomething()">
<div onclick="console.log('触发事件')">

<!-- 正确 -->
<body onload="doSomething()">

<!-- 错误 -->
<body onload="doSomething">
```

>使用on+事件名称指定的函数 只会在事件冒泡时执行

>只能给元素绑定一个事件监听函数 无法绑定多个


_______________________________________________
## 小结

* 第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。

* 第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。

* 第三种EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：
    > 同一个事件可以添加多个监听函数。
    
    > 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数
    > 除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。

_______________________________________

### 事件的冒泡与捕获

一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。

>第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）

>第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。

>第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。


#### Event.currentTarget Event.target

> Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。

* Event.target属性返回原始触发事件的那个节点，即事件最初发生的节点。
* 事件传播过程中，不同节点的监听函数内部的Event.target与Event.currentTarget属性的值是不一样的 前者总是不变的，后者则是指向监听函数所在的那个节点对象。